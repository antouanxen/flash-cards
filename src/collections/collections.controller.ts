import { Body, Controller, Delete, Get, HttpException, HttpStatus, Param, Patch, Post, Req, Res } from '@nestjs/common';
import { CollectionService } from './providers/collections.service';
import { CreateCollectionDto } from './dtos/create-collection.dto';
import { ErrorCodes } from 'src/utils/errorCodes';
import { GetCollectionsDto } from './dtos/get-collections.dto';
import { UpdateCollectionDto } from './dtos/update-collection.dto';
import { FindCollectionByIdDTO } from './dtos/find-collectionById.dto';
import { ApiBody, ApiOperation, ApiParam, ApiResponse, ApiTags } from '@nestjs/swagger';
import prisma from 'prisma/prisma_Client';
import { SyncCollectionsDto } from './dtos/syncCollectionsFromSQLite.dto';
import { Request, Response } from 'express';

@Controller('collections')
@ApiTags('Collections')
export class CollectionController {

    constructor(private readonly collectionService: CollectionService) {}

    @Post('sync_collections')
    @ApiOperation({
        summary: 'Use this endpoint to synchronize a single or a number of collections with the server based on the body, updating the data to the server'
    })
    @ApiBody({
        description: 'Fill the body requirements as shown below',
        schema: { type: 'object', properties: {
            id: { type: 'string', format: 'uuid', example: 'e1e5a6a3-d42e-4e73-9f37-f9a3a5e598ed', description: 'UUID for each of the collections that get synced to the server generated by the SQLite db'},
            name: { type: 'string', example: 'Abc' },
            created_at: { type: 'string/Date', example:'2024-10-08 14:11:29.802', description: 'It creates a timestamp for the collection created, can be optional'},
            updated_at: { type: 'string/Date', example:'2024-10-08 14:11:29.802', description: 'It creates a timestamp for the collection from the most recent update, can be optional'},
            deleted_at: { type: 'string/Date', example:'2024-10-08 14:11:29.802', description: 'It creates a timestamp for the collection that got soft deleted but still exists in the database, can be null also'},
        }},
    })
    @ApiResponse({ status: 201, description: 'A collection is created successfully' })
    @ApiResponse({ status: 400, description: 'Bad request. Could not make that collection'})
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async syncCollections(@Body() syncCollectionsDto: SyncCollectionsDto, @Req() req: Request, @Res() res: Response) {
        const userid = (req as any).res.locals.user
        const { collections } = syncCollectionsDto

        if(!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        const syncedCollections = await this.collectionService.syncCollectionsFromSQLite(collections, userid)

        if (syncedCollections.length > 0) {
            console.log(`A total number of ${syncedCollections.length} collections have been made and synced with the server`);
            res.status(201).json({ syncedCollections})
        } else if (syncedCollections.length === 0) {
            console.log('No collections needed to sync');
            res.status(204).json({message: 'There was no collections to sync with the server'})
        }  
    }

    @Post('create_collection')
    @ApiOperation({
        summary: 'Use this endpoint to create a collection based on the body'
    })
    @ApiBody({
        description: 'Fill the body requirements as shown below',
        schema: { type: 'object', properties: {
            name: { type: 'string', example: 'Abc' },
        }}, required: true  
    })
    @ApiResponse({ status: 201, description: 'A collection is created successfully' })
    @ApiResponse({ status: 400, description: 'Bad request. Could not make that collection'})
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async createCollection(@Body() createCollectionDto: CreateCollectionDto, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if(!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        try {
            console.log('Φτιαχνεις μια συλλογη')
            const collectionToBeCreated = await this.collectionService.createCollection(createCollectionDto, userid)
            console.log('New collection:', collectionToBeCreated);
            console.log('η συλλογη δημιουργηθηκε');
        

            const user = await prisma.user.findUnique({ where: { userid: userid } })
            const userCollections = await prisma.collection.findMany({ where: { userId: user.id , deleted_at: null} })
            console.log(`Και εχει αλλες ${userCollections.length} ακομα`);

            return collectionToBeCreated
        } catch (err: any) {
            console.error('Error creating collection', err)
            throw new HttpException({ message: 'An unexpected error occured to the server', errorCode: ErrorCodes.SERVER_ERROR }, HttpStatus.INTERNAL_SERVER_ERROR) 
        }
    }

    @Get()
    @ApiOperation({ summary: 'Use this endpoint to fetch all collections of the current user based on the token provided by Firebase' })
    @ApiResponse({ status: 200, description: 'All Collections of the user fetched successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'Any collection was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async getAllCollections(getCollectionsDto: GetCollectionsDto, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if(!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        console.log('Εδω παιρνεις ολες τις συλλογες')
        const collections = await this.collectionService.getAllCollections(getCollectionsDto, userid)
        console.log('Τα collections φτασανε')
        console.log('Tο συνολο τους:', collections.length)

        return collections
    }

    @Get(':id')
    @ApiOperation({ summary: 'Use this endpoint to fetch a single collection of the current user based on the token provided by Firebase' })
    @ApiParam({ name: 'id', schema: { type: 'string', format: 'uuid', example: '15c2956b-1d27-4282-89da-d83dd7b44a49', description: 'Unique identifier for the resource' }, required: true })
    @ApiResponse({ status: 200, description: 'Collection of the user fetched successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'That collection was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async getCurrentCollection(@Param('id')  getCollectionWithId: FindCollectionByIdDTO, @Req() req: Request) {
        const userid = (req as any).res.locals.user
        const { id } = getCollectionWithId

        if(!userid) {
            console.error('User ID is invalid')
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        console.log('Εδω παιρνεις τη συγκεκριμενη συλλογη')
        const singleCollection = await this.collectionService.getSingleCollection(id, userid)
        
        console.log('The collection:', singleCollection)
        console.log('Oριστε ενα collection')

        return singleCollection
    }

    @Patch('update_collection/:id')
    @ApiOperation({ summary: 'Use this endpoint to update a single collection of the current user based on the token provided by Firebase' })
    @ApiBody({
        description: 'Fill the body requirements as shown below',
        schema: { type: 'object', properties: {
            name: { type: 'string', example: 'Cba' },
        }}, required: true  
    })
    @ApiParam({ name: 'id', schema: { type: 'string', format: 'uuid', example: '15c2956b-1d27-4282-89da-d83dd7b44a49', description: 'Unique identifier for the resource' }, required: true })
    @ApiResponse({ status: 200, description: 'Collection of the user updated successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'That collection was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async updateCurrentCollection(@Param('id') id: string, @Body('name') name: string, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if(!userid) {
            console.error('User ID is invalid')
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        const updateCollectionDto: UpdateCollectionDto = { id, name }

        console.log('Εδω ενημερωνεις μια συλλογη')
        const updatedCollection = await this.collectionService.updateCollection(updateCollectionDto, userid)
        
        console.log('Updated Collection:', updatedCollection)
        console.log('Ενημερωσες ενα collection')

        return updatedCollection
    }

    @Delete('delete_collection/:id')
    @ApiOperation({ summary: 'Use this endpoint to delete a single collection of the current user based on the token provided by Firebase' })
    @ApiParam({ name: 'id', schema: { type: 'string', format: 'uuid', example: '15c2956b-1d27-4282-89da-d83dd7b44a49', description: 'Unique identifier for the resource' }, required: true })
    @ApiResponse({ status: 200, description: 'Collection of the user deleted successfully' })
    @ApiResponse({ status: 401, description: 'User is Unathorized to proceed' })
    @ApiResponse({ status: 404, description: 'That collection was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async deleteCurrentCollection(@Param('id') id: string, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if (!userid) {
            console.error('User ID is invalid')
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        console.log('Εδω διαγραφεις μια συλλογη')
        const result = await this.collectionService.deleteCollection(id, userid)
        
        if (typeof result === 'string') throw new HttpException({ message: 'Could not delete that collection', errorCode: ErrorCodes.COLLECTION_DELETE_ERROR }, HttpStatus.BAD_REQUEST)
        
        console.log('Διεγραψες ενα collection')
        return { message: 'That collection got deleted. Carry on.'}
    }
}
