import { Body, Controller, Delete, Get, HttpException, HttpStatus, Param, Patch, Post, Req, Res } from '@nestjs/common';
import { CardsService } from './providers/cards.service';
import { CreateCardDto } from './dtos/create-card.dto';
import { ErrorCodes } from 'src/utils/errorCodes';
import { GetCardsDto } from './dtos/get-cards.dto';
import { UpdateCardDto } from './dtos/update-card.dto';
import { ApiBody, ApiOperation, ApiParam, ApiResponse, ApiTags } from '@nestjs/swagger';
import prisma from 'prisma/prisma_Client';
import { SyncCardsDTO } from './dtos/syncCardsFromSQLite.dto';
import { Request, Response } from 'express';

@Controller('cards')
@ApiTags('Cards')
export class CardsController {

    constructor(private readonly cardService: CardsService) {}

    @Post('sync_cards')
    @ApiOperation({
        summary: 'Use this endpoint to synchronize a single or a number of cards with the server based on the body, updating the data to the server'
    })
    @ApiBody({
        description: 'Fill the body requirements as shown below',
        schema: { type: 'array', properties: {
            cardId: { type: 'string', format: 'uuid', example: 'e1e5a6a3-d42e-4e73-9f37-f9a3a5e545io', description: 'UUID for each of the cards that get to sync with the server, generated by the SQLite db'},
            front_text: { type: 'string', example: 'A' },
            back_text: { type: 'string', example: 'B' },
            color: { type: 'string', example: '#FF0000'},
            created_at: { type: 'string/Date', example:'2024-10-08 14:11:29.802', description: 'It creates a timestamp for the card created, can be optional'},
            updated_at: { type: 'string/Date', example:'2024-10-08 14:11:29.802', description: 'It creates a timestamp for the card from the most recent update, can be optional'},
            deleted_at: { type: 'string/Date', example:'2024-10-08 14:11:29.802', description: 'It creates a timestamp for the card that got soft deleted but still exists in the database, can be null also'},
            collectionId: { type: 'string', format: 'uuid', example: 'e1e5a6a3-d42e-4e73-9f37-f9a3a5e678e0', description: 'Optional UUID for the collection/ Create a collection first to implement, can be null also'},
            image_name: { type: 'string', example: 'image-b0d0cb5c-e0dd-4192-9d13-1c3f0da69749.jpg', description: 'Optional name for the image/ Create an image first to implement, can be null also'}
        }, required: ['cardId', 'front_text', 'back_text', 'color']
        },  
    })
    @ApiResponse({ status: 201, description: 'A card is (or a number of them are) synced successfully with the server by being updated or created anew' })
    @ApiResponse({ status: 204, description: 'A card is (or a number of them are) synced successfully with the server but have no changes at all' })
    @ApiResponse({ status: 400, description: 'Bad request. Could not make that card'})
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async syncCards(@Body() syncCardsDTO: SyncCardsDTO, @Req() req: Request, @Res() res: Response) {
        const userid = (req as any).res.locals.user

        const { cards } = syncCardsDTO

        if (!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        const syncedCards = await this.cardService.syncCardsFromSQLite(cards, userid)

        if (syncedCards.length > 0) {
            console.log(`A total number of ${syncedCards.length} cards have been made and synced up with the server`);
            res.status(201).json({ syncedCards })
        } else if (syncedCards.length === 0) {
            console.log('No cards needed to sync');
            res.status(204).json({message: 'There were no cards to sync up with the server'})
        }
    }

    @Post('create_card')
    @ApiOperation({
        summary: 'Use this endpoint to create a card based on the body'
    })
    @ApiBody({
        description: 'Fill the body requirements as shown below',
        schema: { type: 'object', properties: {
            front_text: { type: 'string', example: 'A' },
            back_text: { type: 'string', example: 'B' },
            color: { type: 'string', example: '#FF0000'},
            collectionId: { type: 'string', format: 'uuid', example: 'e1e5a6a3-d42e-4e73-9f37-f9a3a5e678e0', description: 'Optional UUID for the collection/ Create a collection first to implement, can be null also'},
            image_name: { type: 'string', example: 'image-b0d0cb5c-e0dd-4192-9d13-1c3f0da69749.jpg' }
        }, required: ['front_text', 'back_text', 'color']
        },  
    })
    @ApiResponse({ status: 201, description: 'A card is created successfully and gets stored in the database' })
    @ApiResponse({ status: 400, description: 'Bad request. Could not make that card'})
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async createCard(@Body() createCardDto: CreateCardDto, @Req() req: Request) {
        const userid = (req as any).res.locals.user
        
        if (!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        try {
            console.log('Φτιαχνεις μια καρτα')
            const cardToBeCreated = await this.cardService.createCard(createCardDto, userid)
            console.log('New card:', cardToBeCreated);
            console.log('η καρτα δημιουργηθηκε');
           
            const user = await prisma.user.findUnique({ where: { userid: userid } })
            const userCards = await prisma.card.findMany({ where: { userId: user.id, deleted_at: null} })
            console.log(`Και εχει αλλες ${userCards.length} ακομα`);
    
            return cardToBeCreated
        } catch (err: any) {
            console.error('Error creating cards', err)
            throw new HttpException({ message: 'An unexpected error occured to the server', errorCode: ErrorCodes.SERVER_ERROR }, HttpStatus.INTERNAL_SERVER_ERROR)
        }
    }

    @Get()
    @ApiOperation({ summary: 'Use this endpoint to fetch all the cards of the current user based on the token provided by Firebase' })
    @ApiResponse({ status: 200, description: 'All cards of the user fetched successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'Any card was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async getAllCards(getCardsDto: GetCardsDto, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if (!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        console.log('Εδω παιρνεις ολες τις καρτες του χρηστη', userid)
        const cards = await this.cardService.getAllCards(getCardsDto, userid)
        console.log('Οι καρτες φτασανε')
        console.log('Tο συνολο τους:', cards.length)

        return cards
    }

    @Get(':cardId')
    @ApiOperation({ summary: 'Use this endpoint to fetch a single card of the current user based on the token provided by Firebase' })
    @ApiParam({ name: 'cardId', schema: { type: 'string', format: 'uuid', example: 'fbb6d83a-ab25-4fcc-8bd9-38f6a00399f0', description: 'Unique identifier for the resource' }, required: true })
    @ApiResponse({ status: 200, description: 'Card of the user fetched successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'That card was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async getSingleCard(@Param('cardId') cardId: string, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if (!userid) {
            console.error('User ID is invalid');
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        const singleCard = await this.cardService.getSingleCard(cardId, userid)
        console.log('Οριστε η συγκεκριμενη καρτα')

        return singleCard
    }

    @Patch('update_card/:cardId')
    @ApiOperation({ summary: 'Use this endpoint to update a single card of the current user based on the token provided by Firebase' })
    @ApiBody({
        description: 'Fill the body requirements as shown below',
        schema: { type: 'object', properties: {
            front_text: { type: 'string', example: 'C' },
            back_text: { type: 'string', example: 'D' },
            color: { type: 'string', example: '#FF0000'},
            collectionId: { type: 'string', format: 'uuid', example: 'e1e5a6a3-d42e-4e73-9f37-f9a3a5e678e0', description: 'Optional UUID for the collection/ Create a collection first to implement, can be null also'}
        }, required: ['front_text', 'back_text', 'color']
        }, })
    @ApiParam({ name: 'cardId', schema: { type: 'string', format: 'uuid', example: 'fbb6d83a-ab25-4fcc-8bd9-38f6a00399f0', description: 'Unique identifier for the resource' }, required: true })
    @ApiResponse({ status: 200, description: 'Card of the user updated successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'That card was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async updateCurrentCard(@Param('cardId') cardId: string, @Body()  updateCardDto: UpdateCardDto, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if(!userid) {
            console.error('User ID is invalid')
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }
        updateCardDto.id = cardId

        console.log('Ενημερωνεις μια καρτα')
        const updatedCard = await this.cardService.updateCard(updateCardDto, userid)
        console.log('Updated Card:', updatedCard)
        console.log('Ενημερωσες μια καρτα')

        return updatedCard
    }

    @Delete('delete_card/:cardId')
    @ApiOperation({ summary: 'Use this endpoint to delete a single card of the current user based on the token provided by Firebase' })
    @ApiParam({ name: 'cardId', schema: { type: 'string', format: 'uuid', example: 'fbb6d83a-ab25-4fcc-8bd9-38f6a00399f0', description: 'Unique identifier for the resource' }, required: true })
    @ApiResponse({ status: 200, description: 'A Card of the user deleted successfully' })
    @ApiResponse({ status: 401, description: 'User is Unauthorized to proceed' })
    @ApiResponse({ status: 404, description: 'That card was not found' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async deleteCurrentCard(@Param('cardId') cardId: string, @Req() req: Request) {
        const userid = (req as any).res.locals.user

        if (!userid) {
            console.error('User ID is invalid')
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        console.log('Διαγραφεις μια καρτα')
        const result = await this.cardService.deleteCard(cardId, userid)
        
        if (typeof result === 'string') {
            console.error('Error to delete that card')
            throw new HttpException({ message: 'Could not delete that card', errorCode: ErrorCodes.CARD_DELETE_ERROR }, HttpStatus.BAD_REQUEST)
        }
        
        console.log('Διεγραψες μια καρτα')
    }

    @Delete('/total_delete')
    @ApiOperation({ summary: 'Use this endpoint to delete all **CARDS**!!! of the current user based on the token provided by Firebase' })
    @ApiResponse({ status: 200, description: 'All Cards of the user deleted successfully' })
    @ApiResponse({ status: 400, description: 'Bad request' })
    @ApiResponse({ status: 500, description: 'An error occured to the server' })
    public async deleteAllCards(@Req() req: Request) {
        const userid = (req as any).res.locals.user

        if (!userid) {
            console.error('User ID is invalid')
            throw new HttpException({ message: 'User ID is required', errorCode: ErrorCodes.INVALID_CREDENTIAL }, HttpStatus.UNAUTHORIZED)
        }

        const result = await this.cardService.deleteALLCards(userid)

        if (typeof result === 'string') {
            console.error('Error to delete that card')
            throw new HttpException({ message: 'Could not delete that card', errorCode: ErrorCodes.CARD_DELETE_ERROR }, HttpStatus.BAD_REQUEST)
        }

        console.log(`Διεγραψες ολες τις καρτες του χρηστη ${userid}`)
    }
}
